function [PossProblem] = define_MEC(PossProblem,PossMeasurements,index)
% 
% defineMEC — Add the measurement-constraints to a PossProblem structure.
% 
% Syntax
% [PossProblem]=define_MEC(PossProblem, PossMeasurements, index)
% 
% Description
% [PossProblem]=define_MEC(PossProblem, PossMeasurements, index) returns the 
% PossProblem received as input adding the measurements as constraints. 
% The output struct has the following fields: 
% 
% .v 	The vector of fluxes (as a YALMIP decision variable).
% .CB	The constraints-base,i.e.,the set of all constraints(in YALMIP syntax).
% .e1	The vector of slack variables (as a YALMIP decision variable).
% .m1   The vector of slack variables (as a YALMIP decision variable).
% .e2   The vector of slack variables (as a YALMIP decision variable).
% .m2	The vector of slack variables (as a YALMIP decision variable).
% .J 	The objective function penalizing the deviations between fluxes and 
%       measured values, accordingly to alpha and beta.
%     
% The input PossProblem is a struct generated by defineMOC function,
% and defines the model constraints of the MFA problem. The input 
% PossMeasurements is a structure generated by define_PossMeasurements
% or manually, and defines the measurements in possibilistic terms.
% Finally, the vector index indicates the indexes of the measured fluxes 
% in the model.
%
% See also   define_MOC, define_PossMeasurements
% 
% For additional information, please visit https://github.com/kikollan/PFA-Toolbox
%
%=====================================================================================================

% add the slack variables (e, m) to the POSS MFA problem
PossProblem.e1      = sdpvar(size(PossMeasurements.wm,1),1);
PossProblem.m1      = sdpvar(size(PossMeasurements.wm,1),1);
PossProblem.e2      = sdpvar(size(PossMeasurements.wm,1),1);
PossProblem.m2      = sdpvar(size(PossMeasurements.wm,1),1);

% Define the MEC constraints
PossProblem.CB = [PossProblem.CB, PossProblem.v(index)==PossMeasurements.wm+PossProblem.e1-PossProblem.m1+PossProblem.e2-PossProblem.m2];
PossProblem.CB = [PossProblem.CB, PossProblem.e2<=PossMeasurements.e2max];
PossProblem.CB = [PossProblem.CB, PossProblem.m2<=PossMeasurements.m2max];
PossProblem.CB = [PossProblem.CB, PossProblem.e1>=0];
PossProblem.CB = [PossProblem.CB, PossProblem.m1>=0];
PossProblem.CB = [PossProblem.CB, PossProblem.e2>=0];
PossProblem.CB = [PossProblem.CB, PossProblem.m2>=0];

% Define the optimization objective J
PossProblem.J  = PossMeasurements.alpha'*PossProblem.e1+PossMeasurements.beta'*PossProblem.m1;
